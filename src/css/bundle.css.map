{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Comment.svelte",
    "../../Screen.svelte",
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { browser } from \"webextension-polyfill-ts\";\nimport Screen from \"./Screen.svelte\";\nlet addCommentToScreen;\nlet visibleState;\nlet display;\n$: display = visibleState ? \"\" : \"display: none;\";\nlet removeAllComments;\nbrowser.storage.local.get(\"visibility\").then(settings => (visibleState = settings.visibility.visible), () => (visibleState = false));\nconst logStorageChangeListener = (changes, area) => {\n    // console.log(\"Change in storage area: \" + area);\n    let changedItems = Object.keys(changes);\n    for (let item of changedItems) {\n        /* For Debugging */\n        // console.log(item + \" has changed:\");\n        // console.log(\"Old value: \");\n        // console.log(changes[item].oldValue);\n        // console.log(\"New value: \");\n        // console.log(changes[item].newValue);\n        itemCheck: {\n            if (item === \"visibility\" && \"visible\" in changes[item].newValue) {\n                // console.info(\"visibility\");\n                const oldVisibleState = visibleState;\n                visibleState = !!changes[item].newValue[\"visible\"];\n                if (oldVisibleState === true && visibleState === false) {\n                    removeAllComments();\n                }\n                break itemCheck;\n            }\n            if (item === \"newComment\" && \"text\" in changes[item].newValue) {\n                const comment = changes[item].newValue[\"text\"];\n                console.info(\"incoming: \" + comment);\n                addComment(comment);\n                break itemCheck;\n            }\n        }\n    }\n};\nconst addComment = (comment) => {\n    // コメントDIVを表示しない間は新規コメントを破棄する\n    if (!visibleState)\n        return false;\n    if (comment == null)\n        return false;\n    comment = comment.trimEnd();\n    if (comment === \"\")\n        return false;\n    return addCommentToScreen(comment);\n};\nconst showScreen = () => (display = \"\");\nconst hideScreen = () => (display = \"display: none;\");\nconst css = browser.extension.getURL(\"/css/bundle.css\");\nbrowser.storage.onChanged.addListener(logStorageChangeListener);\n</script>\n\n<style>\n.screen {\n  width: 100vw;\n  height: 100vh;\n  z-index: 99999;\n  position: fixed;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n</style>\n\n<svelte:head>\n  <link rel=\"stylesheet\" href={css} />\n</svelte:head>\n<div class=\"screen\" style={display}>\n  <Screen bind:addComment={addCommentToScreen} bind:removeAllComments />\n</div>\n",
    "<script lang=\"ts\">/**\n * 規定の秒数の間親要素を流れるコメント\n * 流れ終わったコメントは親要素の責任で処理する。\n * CSSアニメーションを利用していて、アニメーションが終わると `on:animationEnd` カスタムイベントを発火させる\n */\nimport { animationend } from \"./animationend\";\nexport let text;\nexport let topPercentage;\nexport let opacity = 0.8;\nexport let color = \"white\";\nexport let style = \"\";\nexport let duration;\nlet comment;\nlet divHeight;\nexport let fontSize = undefined;\n$: fontSize = Math.round(divHeight * 9) / 10;\nexport const getOffsetLeft = () => {\n    return comment.offsetLeft;\n};\nexport const getWidth = () => {\n    return comment.clientWidth;\n};\n</script>\n\n<style>\ndiv {\n  text-align: start;\n  height: 10%;\n  width: auto;\n}\n\nspan {\n  white-space: pre;\n  margin: 0;\n}\n\n.comment-box {\n  position: absolute;\n  width: 100%;\n}\n\n.comment {\n  position: inherit; /* 何故か必要 */\n  display: inline-block;\n  animation: linear alternate;\n  animation-name: run;\n  /* -webkit-text-stroke-color: darkslategray; */\n  /* -webkit-text-stroke-width: 1px; */\n  text-shadow: 0px 0px 3px darkslategray;\n  font-weight: 600;\n  font-family: \"ＭＳ Ｐゴシック\", \"MS PGothic\", \"メイリオ\", \"Meiryo\",\n    \"ヒラギノ角ゴシック\", \"Hiragino Sans\";\n}\n\n.white.opacityHard {\n  color: rgba(236, 236, 236, 0.5);\n}\n\n.white {\n  color: rgb(236, 236, 236);\n}\n\n.black {\n  color: darkslategray;\n}\n\n@keyframes run {\n  0% {\n    left: calc(100% + 5px);\n    transform: translateX(0%);\n  }\n  100% {\n    left: calc(0% - 5px);\n    transform: translateX(-100%);\n  }\n}\n</style>\n\n<svelte:options immutable accessors />\n<!-- 規定の秒数の間親要素を流れるコメント\n  流れ終わったコメントは親要素の責任で処理する。\n  CSSアニメーションを利用していて、アニメーションが終わると `on:animationEnd` カスタムイベントを発火させる -->\n<div\n  class=\"comment-box\"\n  bind:clientHeight={divHeight}\n  style=\"top: {topPercentage}%;\">\n  <span\n    class=\"comment {color}\"\n    bind:this={comment}\n    use:animationend\n    on:animationEnd\n    style=\"font-size: {fontSize}px; opacity: {opacity}; animation-duration: {duration}s;\n    {style}\">\n    {text}\n  </span>\n</div>\n",
    "<script lang=\"ts\">import Comment from \"./Comment.svelte\";\nimport { v4 as uuid } from \"uuid\";\nclass CommentData {\n    constructor(text) {\n        this.text = text;\n        this.id = uuid();\n        this.position = calcCorrectPosition();\n        this.top = this.position * 10;\n    }\n}\nlet newComment = null;\nlet comments = [];\nlet screenWidth;\nlet getNewCommentWidth;\nlet animationDuration = 5; // seconds\nexport function addComment(comment) {\n    comment = comment.trimEnd();\n    if (comment === \"\")\n        return false;\n    // Set new comment to hidden DOM to calculate actual width\n    newComment = comment;\n    comments = [...comments, new CommentData(newComment)];\n    newComment = null;\n    return false;\n}\nfunction removeComment(id) {\n    comments = comments.filter((t) => t.id !== id);\n}\nexport function removeAllComments() {\n    comments = [];\n}\nfunction calcCorrectPosition() {\n    if (comments.length == 0)\n        return 0;\n    const availablePositions = new Set([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    const remaining = comments\n        .map(({ position, getOffsetLeft, getWidth }) => {\n        const offsetLeft = getOffsetLeft();\n        const width = getWidth();\n        const fromRightPercents = 100 - percentageRounded((offsetLeft + width) / screenWidth);\n        const wontOverlap = willNotOverlap(width, offsetLeft);\n        const insertable = fromRightPercents < 1 ? false : wontOverlap;\n        // console.log({offsetLeft, width, screenWidth, fromRightPercents, wontOverlap, insertable})\n        return { position, insertable };\n    })\n        .reduce((remaining, { position, insertable }) => {\n        if (!insertable) {\n            remaining.delete(position);\n        }\n        return remaining;\n    }, availablePositions);\n    const position = remaining.size == 0 ? 0 : Math.min(...remaining);\n    return position;\n}\n/**\n * 進行速度の比からコメントを同じ行に置いてよいか判断する\n */\nfunction willNotOverlap(width, offsetLeft) {\n    const fromRight = screenWidth - (width + offsetLeft);\n    const newCommentWidth = getNewCommentWidth();\n    if (fromRight < 0)\n        return false;\n    // const oldWordArrivalTime = animationDuration * (screenWidth - fromRight) / (screenWidth + width)\n    // const newWordArrivalTime = animationDuration * screenWidth / (screenWidth + newCommentWidth)\n    const discriminant = (screenWidth - fromRight) / (screenWidth + width) -\n        screenWidth / (screenWidth + newCommentWidth);\n    return discriminant <= 0;\n}\n/**\n * 小数第一位までの100分率を計算する\n */\nconst percentageRounded = (value) => Math.round(value * 1000) / 10;\n</script>\n\n<style>\n.screen {\n  /* background: #eeeeee; */\n  /* background: rgba(128, 128, 128, 0.3); */\n  /* width: 1280px; */\n  /* height: 720px; */\n  /* margin-left: 100px; */\n  /* display: inline-flex; */\n  /* flex-direction: column; */\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  pointer-events: none;\n}\n</style>\n\n<div class=\"screen\" bind:clientWidth={screenWidth}>\n  <Comment\n    bind:getWidth={getNewCommentWidth}\n    text={\"\"}\n    topPercentage={0}\n    duration={0}\n    style=\"opacity: 0; position: absolute;\" />\n  {#each comments as { id, text, top, getOffsetLeft, getWidth } (id)}\n    <Comment\n      {text}\n      bind:getOffsetLeft\n      bind:getWidth\n      topPercentage={top}\n      color={'white'}\n      duration={animationDuration}\n      on:animationEnd={() => removeComment(id)} />\n  {/each}\n</div>\n",
    "<script lang=\"ts\">import Toggle from \"./src/Toggle.svelte\";\nimport { browser } from \"webextension-polyfill-ts\";\nlet visibleState;\nbrowser.storage.local.get(\"visibility\").then(settings => (visibleState = settings.visibility.visible), () => (visibleState = false));\nconst onVisibleToggle = () => {\n    browser.storage.local.set({\n        visibility: { visible: visibleState }\n    });\n};\n</script>\n\n<style>\ndiv {\n  width: 10rem;\n}\n</style>\n\n<svelte:head>\n  <link rel=\"stylesheet\" href=\"/css/pretty-checkbox.min.css\" />\n  <link rel=\"stylesheet\" href=\"/css/bundle.css\" />\n</svelte:head>\n<div>\n  <Toggle\n    bind:state={visibleState}\n    onLabel={'コメント表示中'}\n    offLabel={'コメント非表示中'}\n    on:change={onVisibleToggle} />\n</div>\n"
  ],
  "names": [],
  "mappings": "AAuDA,OAAO,eAAC,CAAC,AACP,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,cAAc,CAAE,IAAI,AACtB,CAAC;ACtCD,GAAG,eAAC,CAAC,AACH,UAAU,CAAE,KAAK,CACjB,MAAM,CAAE,GAAG,CACX,KAAK,CAAE,IAAI,AACb,CAAC,AAED,IAAI,eAAC,CAAC,AACJ,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,CAAC,AACX,CAAC,AAED,YAAY,eAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,AACb,CAAC,AAED,QAAQ,eAAC,CAAC,AACR,QAAQ,CAAE,OAAO,CACjB,OAAO,CAAE,YAAY,CACrB,SAAS,CAAE,MAAM,CAAC,SAAS,CAC3B,cAAc,CAAE,kBAAG,CAGnB,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,aAAa,CACtC,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,UAAU,CAAC,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC;IACtD,WAAW,CAAC,CAAC,eAAe,AAChC,CAAC,AAED,MAAM,YAAY,eAAC,CAAC,AAClB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,AACjC,CAAC,AAED,MAAM,eAAC,CAAC,AACN,KAAK,CAAE,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,AAC3B,CAAC,AAED,MAAM,eAAC,CAAC,AACN,KAAK,CAAE,aAAa,AACtB,CAAC,AAED,WAAW,kBAAI,CAAC,AACd,EAAE,AAAC,CAAC,AACF,IAAI,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CACtB,SAAS,CAAE,WAAW,EAAE,CAAC,AAC3B,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,IAAI,CAAE,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CACpB,SAAS,CAAE,WAAW,KAAK,CAAC,AAC9B,CAAC,AACH,CAAC;ACAD,OAAO,eAAC,CAAC,AAQP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,QAAQ,CAAE,QAAQ,CAClB,cAAc,CAAE,IAAI,AACtB,CAAC;AC5ED,GAAG,cAAC,CAAC,AACH,KAAK,CAAE,KAAK,AACd,CAAC"
}